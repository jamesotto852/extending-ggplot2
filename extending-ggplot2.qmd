---
format: 
  revealjs:
    theme: [simple, presentation.css]
    auto-animate-easing: ease-in-out
    footer: "James Otto (Baylor University)"
    self-contained: false
    slide-number: true
    df-print: paged
knitr:
  opts_chunk: 
    fig-format: png
    echo: true
    collapse: true
    comment: "#>"
---


```{r setup_environment}
#| include: false
library("here")
library("tidyverse") 
library("patchwork")
library("ggdensity")

theme_set(theme_bw(13)) 
theme_update(
  panel.grid.minor = element_blank()
)

# Masking default method to hide rownames (mildly dangerous!)
# print.data.frame <- \(x) base::print.data.frame(x, row.names = FALSE)

```

# Introduction

---

Go through examples of **ggplot2** extensions

# A first look at **ggproto** objects

## {auto-animate=true}

```{r}
df <- data.frame(
  x = rnorm(10),
  y = rnorm(10)
)
```

## {auto-animate=true}
```{r}
#| include: false
set.seed(1)
```
```{r}
df <- data.frame(
  x = rnorm(10),
  y = rnorm(10)
)

df
```

---

```{r}
library("ggplot2")

ggplot(df, aes(x, y)) +
  geom_point()
```

---

```{r, class.output = "r"}
#| code-line-numbers: false
#| comment: ""
#| collapse: false

geom_point
```

---

```{r}
ggplot(df, aes(x, y)) +
  layer(geom = GeomPoint, stat = StatIdentity, position = "identity")
```

---

**ggplot2** is built on the ggproto object oriented system.

`GeomPoint` is an object with methods and fields that encode the relevant 
procedures and defaults to create a scatterplot.

---

```{r}
#| code-line-numbers: "|8" 
GeomPoint
```

---

```{r}
#| code-line-numbers: "|8-18" 
GeomPoint$draw_panel
```
<!-- "Graphical primitives" -->

---

```{r}
#| code-line-numbers: "4" 
GeomPoint
```

---

```{r}
GeomPoint$default_aes
```

---

It is simple to extend via inheritance,
creating `GeomPointNew` from `GeomPoint` with a few adjustments to the default aesthetic options.

Using the `ggproto()` function...

---

```{r}
GeomPointNew <- ggproto("GeomPointNew", GeomPoint,
                        
  default_aes = aes(
    shape = 21,
    colour = "black",
    size = 2,
    fill = "slateblue",
    alpha = NA,
    stroke = .5
  )
  
)
```

---

```{r}
#| code-line-numbers: "|8" 
GeomPointNew
```

---

```{r}
#| code-line-numbers: "|8-18" 
GeomPointNew$draw_panel
```

---

```{r}
#| code-line-numbers: "4" 
GeomPointNew
```

---

```{r}
GeomPointNew$default_aes
```

---

```{r}
ggplot(df, aes(x, y)) +
  layer(geom = GeomPointNew, stat = StatIdentity, position = "identity")
```

---

```{r}
geom_point_new <- function(mapping = NULL, data = NULL, 
                           stat = "identity", position = "identity", 
                           ...,
                           na.rm = FALSE,
                           show.legend = NA,
                           inherit.aes = TRUE) {
  layer(
    data = data,
    mapping = mapping,
    stat = stat,
    geom = GeomPointNew,
    position = position,
    show.legend = show.legend,
    inherit.aes = inherit.aes,
    params = list(
      na.rm = na.rm,
      ...
    )
  )
}
```

---

```{r}
ggplot(df, aes(x, y)) +
  geom_point_new()
```


# Extending stats 

---

Introduce travelling salesperson problem with simple graphics

## {auto-animate=true}

```{r}
library("TSP")

dist_mat <- dist(df, diag = TRUE, upper = TRUE)
atsp <- as.ATSP(dist_mat)
tour <- solve_TSP(atsp)
```

## {auto-animate=true}

```{r}
library("TSP")

dist_mat <- dist(df, diag = TRUE, upper = TRUE)
atsp <- as.ATSP(dist_mat)
tour <- solve_TSP(atsp)

tour
```

## {auto-animate=true}

```{r}
library("TSP")

dist_mat <- dist(df, diag = TRUE, upper = TRUE)
atsp <- as.ATSP(dist_mat)
tour <- solve_TSP(atsp)

str(tour)
```


## {auto-animate=true}

```{r}
df_sorted <- df[tour,]
```

## {auto-animate=true}

```{r}
df_sorted <- df[tour,]

df_sorted
```

---

```{r}
ggplot(df_sorted, aes(x, y)) +
  geom_path() +
  geom_point_new() 

```

---

```{r}
StatSalesperson <- ggproto("StatSalesperson", Stat,
                           
  compute_group = function(data, scales) {
    
    dist_mat <- dist(data[,c("x", "y")], diag = TRUE, upper = TRUE)
    atsp <- as.ATSP(dist_mat)
    tour <- solve_TSP(atsp)
    
    data[tour,]
    
  },
  
  required_aes = c("x", "y")                     
)
```

---

```{r}
stat_salesperson <- function(mapping = NULL, data = NULL, 
                       geom = GeomPath, position = "identity",
                       ...,
                       na.rm = FALSE, 
                       show.legend = NA, 
                       inherit.aes = TRUE) {
  layer(
    stat = StatSalesperson, data = data, mapping = mapping, geom = geom, 
    position = position, show.legend = show.legend, inherit.aes = inherit.aes,
    params = list(na.rm = na.rm, ...)
  )
}
```

---

```{r}
ggplot(df, aes(x, y)) +
  stat_salesperson() +
  geom_point_new() 

```

---

```{r}
StatSalesperson <- ggproto("StatSalesperson",  Stat,
                           
  compute_group = function(data, scales, method = "nearest_insertion") {
    
    dist_mat <- dist(data[,c("x", "y")], diag = TRUE, upper = TRUE)
    atsp <- as.ATSP(dist_mat)
    tour <- solve_TSP(atsp, method)
    
    data[tour,]
    
  },
  
  required_aes = c("x", "y")                     
)
```

---

```{r}
stat_salesperson <- function(mapping = NULL, data = NULL, 
                       geom = GeomPath, position = "identity",
                       ...,
                       method = "nearest_insertion",
                       na.rm = FALSE, 
                       show.legend = NA, 
                       inherit.aes = TRUE) {
  layer(
    stat = StatSalesperson, 
    data = data,
    mapping = mapping,
    geom = geom,
    position = position,
    show.legend = show.legend,
    inherit.aes = inherit.aes,
    params = list(
      method = method,
      na.rm = na.rm,
      ...
    )
  )
}
```

---

```{r}
ggplot(df, aes(x, y)) +
  stat_salesperson(method = "identity") +
  geom_point_new() 
```

---

```{r}
ggplot(df, aes(x, y)) +
  stat_salesperson(method = "random") +
  geom_point_new() 
```

---

```{r}
ggplot(df, aes(x, y)) +
  stat_salesperson() +
  geom_point_new() 
```

---

```{r}
GeomSalesperson <- ggproto("GeomSalesperson", GeomPath)

geom_salesperson <- function(mapping = NULL, data = NULL, 
                             stat = StatSalesperson, position = "identity", 
                             ...,
                             na.rm = FALSE,
                             show.legend = NA,
                             inherit.aes = TRUE) {
  layer(
    data = data,
    mapping = mapping,
    stat = stat,
    geom = GeomSalesperson,
    position = position,
    show.legend = show.legend,
    inherit.aes = inherit.aes,
    params = list(
      na.rm = na.rm,
      ...
    )
  )
}

```

---

```{r}
ggplot(df, aes(x, y)) +
  geom_salesperson() +
  geom_point_new() 

```

<!-- --- -->

<!-- Note: generally, it's good to pick defaults that match up with defaults in **ggplot2** functions.  -->
<!-- I'm specifically choosing alternative values to demonstrate how things can be changed. -->


# Extending geoms (complete graphs)

---

Minor Introduction to grobs, reference book on grid graphics

Use `segmentsGrob()` as an example!

---

Introduction to complete graphs

---

```{r}
df_expanded <- df[rep(1:nrow(df), each = nrow(df)), ]

df_expanded
```

---

```{r}
df_expanded$xend <- rep(df$x, times = nrow(df))
df_expanded$yend <- rep(df$y, times = nrow(df))

df_expanded
```

---

:::{.r-stack}

:::{.fragment .semi-fade-out fragment-index=1}
```{r}
ggplot(df_expanded, aes(x, y, xend = xend, yend = yend)) +
  geom_segment()
```
:::

:::{.fragment fragment-index=1}

:::{.callout-note appearance="simple"}
## A classic question

Is this a statistical transformation or a graphical operation?
:::

:::

:::

---

A slide discussing the differences between `Stat` and `Geom` objects
 
* `Stats` are used for ____
* `Geoms` are used for ____

---

```{r}
#| code-line-numbers: "|3-21|23|25|27-32|34" 
GeomComplete <- ggproto("GeomComplete", Geom,
                        
  draw_panel = function(data, panel_params, coord) {
    
    data_expanded <- data[rep(1:nrow(data), each = nrow(data)), ]
    data_expanded$xend <- rep(data$x, times = nrow(data))
    data_expanded$yend <- rep(data$y, times = nrow(data))
    
    coord <- coord$transform(data_expanded, panel_params)
    
    grid::segmentsGrob(coord$x, coord$y, coord$xend, coord$yend,
      default.units = "native",
      gp = grid::gpar(
        col = alpha(coord$colour, coord$alpha),
        fill = alpha(coord$colour, coord$alpha),
        lwd = coord$linewidth * .pt,
        lty = coord$linetype
      )
    )
    
  },
  
  required_aes = c("x", "y"),
  
  non_missing_aes = c("linetype", "linewidth", "shape"),
  
  default_aes = aes(
    colour = "black",
    linewidth = 0.5,
    linetype = 1,
    alpha = NA
  ),
 
  draw_key = draw_key_path
  
)
```

---

```{r}
geom_complete <- function(mapping = NULL, data = NULL, 
                          stat = StatIdentity, position = "identity", 
                          ...,
                          na.rm = FALSE,
                          show.legend = NA,
                          inherit.aes = TRUE) {
  layer(
    data = data,
    mapping = mapping,
    stat = stat,
    geom = GeomComplete,
    position = position,
    show.legend = show.legend,
    inherit.aes = inherit.aes,
    params = list(
      na.rm = na.rm,
      ...
    )
  )
}
```

---

```{r}
ggplot(df, aes(x, y)) +
  geom_complete()
```


# Why extend?


---

As we saw previously, we can do calculations outside of **ggplot2** without the need to define a custom `Stat` object:

```{r, eval = FALSE}
dist_mat <- dist(df, diag = TRUE, upper = TRUE)
atsp <- as.ATSP(dist_mat)
tour <- solve_TSP(atsp)

df_sorted <- df[tour,]

ggplot(df_sorted, aes(x, y)) +
  geom_path() +
  geom_point_new() 
```

## {auto-animate=true}

What if we want to plot multiple groups? 

```{r}
#| eval: false
df_mult <- data.frame(
  x = rnorm(3 * 10),
  y = rnorm(3 * 10),
  class = rep(c("a", "b", "c"), each = 10)
)
```

## {auto-animate=true}

What if we want to plot multiple groups? 

```{r}
#| include: false
set.seed(1)
```
```{r}
df_mult <- data.frame(
  x = rnorm(3 * 10),
  y = rnorm(3 * 10),
  class = rep(c("a", "b", "c"), each = 10)
)

df_mult
```

---

Split-Apply-Combine!

## {auto-animate=true}

```{r}
#| eval: false
# Split

df_mult_split <- split(df_mult[,c("x", "y")], df_mult$class)
```

## {auto-animate=true}

```{r}
# Split

df_mult_split <- split(df_mult[,c("x", "y")], df_mult$class)

str(df_mult_split)
```


## {auto-animate=true}

```{r}
# Split

df_mult_split <- split(df_mult[,c("x", "y")], df_mult$class)

df_mult_split$a
```

## {auto-animate=true}

```{r}
# Split

df_mult_split <- split(df_mult[,c("x", "y")], df_mult$class)

df_mult_split$b
```

## {auto-animate=true}

```{r}
# Split

df_mult_split <- split(df_mult[,c("x", "y")], df_mult$class)

df_mult_split$c
```

<!-- ## {auto-animate=true auto-animate-restart} -->
## {auto-animate=true}

```{r}
#| eval: false
# Apply

class_sols <-
  df_mult_split |>
  lapply(dist, diag = TRUE, upper = TRUE) |>
  lapply(as.ATSP) |>
  lapply(solve_TSP) 
```

## {auto-animate=true}

```{r}
# Apply

class_sols <-
  df_mult_split |>
  lapply(dist, diag = TRUE, upper = TRUE) |>
  lapply(as.ATSP) |>
  lapply(solve_TSP) 

str(class_sols)
```

## {auto-animate=true}

```{r}
#| eval: false
# Apply

reorder_rows_by_indices <- function(df, i) df[i,]
df_mult_split <- Map(reorder_rows_by_indices, df_mult_split, class_sols) 
```

## {auto-animate=true}

```{r}
# Apply

reorder_rows_by_indices <- function(df, i) df[i,]
df_mult_split <- Map(reorder_rows_by_indices, df_mult_split, class_sols) 

str(df_mult_split)
```

## {auto-animate=true}

```{r}
# Apply

reorder_rows_by_indices <- function(df, i) df[i,]
df_mult_split <- Map(reorder_rows_by_indices, df_mult_split, class_sols) 

df_mult_split$a
```

## {auto-animate=true}

```{r}
# Apply

reorder_rows_by_indices <- function(df, i) df[i,]
df_mult_split <- Map(reorder_rows_by_indices, df_mult_split, class_sols) 

df_mult_split$b
```

## {auto-animate=true}

```{r}
# Apply

reorder_rows_by_indices <- function(df, i) df[i,]
df_mult_split <- Map(reorder_rows_by_indices, df_mult_split, class_sols) 

df_mult_split$c
```

## {auto-animate=true}

```{r}
#| eval: false
# Combine

df_mult_ordered <- unsplit(df_mult_split, df_mult$class)
df_mult_ordered$class <- df_mult$class
```

## {auto-animate=true}

```{r}
# Combine

df_mult_ordered <- unsplit(df_mult_split, df_mult$class)
df_mult_ordered$class <- df_mult$class
  
df_mult_ordered
```

---

```{r}
ggplot(df_mult_ordered, aes(x, y)) +
  geom_path() +
  geom_point_new() +
  facet_wrap(vars(class))
```

---

:::{.r-stack}

:::{.fragment .semi-fade-out fragment-index=1}
```{r}
#| eval: false
# Split
df_mult_split <- split(df_mult[,c("x", "y")], df_mult$class)

# Apply
class_sols <-
  df_mult_split |>
  lapply(dist, diag = TRUE, upper = TRUE) |>
  lapply(as.ATSP) |>
  lapply(solve_TSP) 

reorder_rows_by_indices <- function(df, i) df[i,]
df_mult_split <- Map(reorder_rows_by_indices, df_mult_split, class_sols) 

# Combine
df_mult_ordered <- unsplit(df_mult_split, df_mult$class)
df_mult_ordered$class <- df_mult$class
```
:::

:::{.fragment fragment-index=1}
:::{.callout-note appearance="simple" icon=false}
Instead, we can let **ggplot2** do this for us!
:::
:::

:::

---

```{r}
ggplot(df_mult, aes(x, y)) +
  geom_salesperson() +
  geom_point_new() +
  facet_wrap(vars(class)) 
```


---

:::{.r-stack}

:::{.fragment .semi-fade-out fragment-index=1}
```{r}
ggplot(df_mult, aes(x, y)) +
  geom_salesperson(size = 2, color = "firebrick") +
  geom_complete(alpha = .3) +
  geom_point_new(size = 3) +
  facet_wrap(vars(class)) +
  theme_minimal()
```
:::

:::{.fragment fragment-index=1}

:::{.callout-note appearance="simple"}
## Understanding the internals

**ggplot2** is using the same split-apply-combine strategy for each layer, 
`$compute_layer()` and `$draw_layer()` methods call `$compute_panel()` or `$draw_panel()` for each `class`!
:::

:::

:::

---

```{r}
#| code-line-numbers: "1|8-25|19-24|23" 
GeomComplete$draw_layer
```

---

```{r}
#| code-line-numbers: "1|8-26|19-25|21" 
StatSalesperson$compute_layer
```


